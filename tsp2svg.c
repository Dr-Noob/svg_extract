#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <stdbool.h>
#include <libgen.h>

#define OUTPUT_FILENAME "solved.svg" 
#define SVG_HEADER "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n" \
                   "<!-- SVG generated by https://github.com/Dr-Noob -->\n" \
                   "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n" \
                   "<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"%dpx\" height=\"%dpx\">\n" \
                   "<g fill=\"black\" stroke=\"none\">\n"
#define SVG_TAIL "</g>\n" \
                 "</svg>\n"        
#define SVG_PATH "<path d=\"M %.3f,%.3f L %.3f,%.3f L %.3f,%.3f L %.3f,%.3f z\"/>"   
                 
#define POINT_CX 0
#define POINT_CY 1
#define POINT_R  2                 
                   
int int_length(int num) { return floor(log10(abs(num))) + 1; }

bool get_svg_dims(int * width, int * height, char * svg_buffer) {
  char* tmp;
  char* svg_width_ptr;
  char* svg_height_ptr;
  char* svg_width;
  char* svg_height;
  
  // Width
  tmp = strstr(svg_buffer, "<svg width=");
  if(tmp == NULL) {
    fprintf(stderr, "[%s:%d] Could not find svg width\n", __FILE__, __LINE__);
    return false;
  }
  
  svg_width_ptr = tmp + 12;
  tmp = strstr(svg_width_ptr, "\" ");
  if(tmp == NULL) {
    fprintf(stderr, "[%s:%d] Failed to parse svg width\n", __FILE__, __LINE__);
    return false;    
  }
  
  if((svg_width = malloc(sizeof(char) * (tmp-svg_width_ptr+1))) == NULL) {
    fprintf(stderr, "[%s:%d] ", __FILE__, __LINE__); perror("malloc");
    return false;    
  }
  strncpy(svg_width, svg_width_ptr, tmp-svg_width_ptr);
  *width = atoi(svg_width);
  
  // Height
  tmp = strstr(svg_width_ptr, "height=");
  if(tmp == NULL) {
    fprintf(stderr, "[%s:%d] Could not find svg height\n", __FILE__, __LINE__);
    return false;
  }
  
  svg_height_ptr = tmp + 8;
  tmp = strstr(svg_height_ptr, "\" ");
  if(tmp == NULL) {
    fprintf(stderr, "[%s:%d] Failed to parse svg height\n", __FILE__, __LINE__);
    return false;    
  }
  
  if((svg_height = malloc(sizeof(char) * (tmp-svg_height_ptr+1))) == NULL) {
    fprintf(stderr, "[%s:%d] ", __FILE__, __LINE__); perror("malloc");
    return false;    
  }
  strncpy(svg_height, svg_height_ptr, tmp-svg_height_ptr);
  *height = atoi(svg_height);
  
  return true;  
}

int* cyc_to_array(char * cyc_buffer) {
  int n = 0;
  char * aux = cyc_buffer;    
  char * tmp;
  char coord[20];
  int c;
  
  while((aux = strchr(aux, '\n')) != NULL) {
    n++;   
    aux++;
  }
  
  int* cyc_array = malloc(sizeof(int) * n);
  aux = cyc_buffer-1;
  
  for(int i=0;i<n;i++) {
    aux++;
    tmp = strchr(aux, '\n');
    strncpy(coord, aux, tmp-aux);
    coord[tmp-aux] = 0;
    c = atoi(coord);
    
    cyc_array[i] = c;
    aux = strchr(aux, '\n');
  }
  
  return cyc_array;
}

void get_path(float** path_arr, float* point1, float* point2) {
  (*path_arr)[0] = point1[POINT_CX] - point1[POINT_R]/2;
  (*path_arr)[1] = point1[POINT_CY] - point1[POINT_R]/2;
  (*path_arr)[2] = point1[POINT_CX] + point1[POINT_R]/2;
  (*path_arr)[3] = point1[POINT_CY] + point1[POINT_R]/2;
  (*path_arr)[4] = point2[POINT_CX] - point2[POINT_R]/2;
  (*path_arr)[5] = point2[POINT_CY] - point2[POINT_R]/2;
  (*path_arr)[6] = point2[POINT_CX] + point2[POINT_R]/2;
  (*path_arr)[7] = point2[POINT_CY] + point2[POINT_R]/2;
}

bool parse_line(char* line, float** point) {
  // <circle cx="887.725" cy="581.982" r="0.610566" fill="rgb(0,0,0)" />    
  char* tmp;
  char* svg_ptr;
  char svg_buffer[100];
  
  // CX
  tmp = strstr(line, "<circle cx=");
  if(tmp == NULL) {
    fprintf(stderr, "[%s:%d] Could not find circle cx\n", __FILE__, __LINE__);
    return false;
  }
  
  svg_ptr = tmp + 12;
  tmp = strstr(svg_ptr, "\" ");
  if(tmp == NULL) {
    fprintf(stderr, "[%s:%d] Failed to parse circle cx\n", __FILE__, __LINE__);
    return false;    
  }
  
  strncpy(svg_buffer, svg_ptr, tmp-svg_ptr);
  (*point)[POINT_CX] = atof(svg_buffer);
  
  // CY
  tmp = strstr(line, "cy=");
  if(tmp == NULL) {
    fprintf(stderr, "[%s:%d] Could not find circle cy\n", __FILE__, __LINE__);
    return false;
  }
  
  svg_ptr = tmp + 4;
  tmp = strstr(svg_ptr, "\" ");
  if(tmp == NULL) {
    fprintf(stderr, "[%s:%d] Failed to parse circle cy\n", __FILE__, __LINE__);
    return false;    
  }
  
  strncpy(svg_buffer, svg_ptr, tmp-svg_ptr);
  (*point)[POINT_CY] = atof(svg_buffer);
  
  // R
  tmp = strstr(line, "r=");
  if(tmp == NULL) {
    fprintf(stderr, "[%s:%d] Could not find circle r\n", __FILE__, __LINE__);
    return false;
  }
  
  svg_ptr = tmp + 3;
  tmp = strstr(svg_ptr, "\" ");
  if(tmp == NULL) {
    fprintf(stderr, "[%s:%d] Failed to parse circle r\n", __FILE__, __LINE__);
    return false;    
  }
  
  strncpy(svg_buffer, svg_ptr, tmp-svg_ptr);
  (*point)[POINT_R] = atof(svg_buffer);
  
  return true;
}

int get_svgpath_line(char** svgpath_line, float* path_arr) {
  return sprintf(*svgpath_line, SVG_PATH, path_arr[0], path_arr[1], path_arr[2], path_arr[3], path_arr[4], path_arr[5], path_arr[6], path_arr[7]);     
}

void write_line(char** write_buffer, char* line, int bytes_to_write) {
  strncpy(*write_buffer, line, bytes_to_write);
  
  //If found \r, original file ending was \r\n, replace \r with \n
  (*write_buffer)[bytes_to_write-1] = '\n';
  *write_buffer += bytes_to_write;
}

char* build_tsp2svg(int* cyc_array, char* svg_buffer, int* size_to_write) {  
  int buffer_size = 1<<20;  
  int ret;
  int svg_width;
  int svg_height;
  int distance;
  float* path_arr = malloc(sizeof(float) * 8); // 4 points
  float* point1 = malloc(sizeof(float) * 3); // x, y, and r
  float* point2 = malloc(sizeof(float) * 3); // x, y, and r
  char* built_buffer = malloc(sizeof(char) * buffer_size);
  char* write_buffer = built_buffer;
  char* aux1 = svg_buffer;
  char* aux2 = NULL;
  char* tmp1 = NULL;
  char* tmp2 = NULL;
  char* svgpath_line = malloc(sizeof(char) * (strlen(SVG_PATH) - 4*8 + 10*8));
  // Substract %.3f format (4*8) and add values itself (we assume there will not be a number bigger than 100000.000)
  
  // We have aux1/2 and tmp1/2 because we need to look two lines at a time, to
  // be able to draw the line between two points. aux stores the begin of the 
  // line, and tmp stores the end.
  //
  // aux1 -> line1
  // aux2 -> line2
  //         line3
  //         ...
  
  if(!get_svg_dims(&svg_width, &svg_height, svg_buffer)) 
    return NULL;      

  // HEADER
  int total_bytes = strlen(SVG_HEADER)-4 + int_length(svg_width) + int_length(svg_height) + 1;
  if((ret = snprintf(write_buffer, total_bytes, SVG_HEADER, svg_width, svg_height)) != total_bytes-1) {
    fprintf(stderr, "[%s:%d] snprintf: Wrote %d instead of %d bytes\n", __FILE__, __LINE__, ret, total_bytes-1);
    return NULL;
  }  
  write_buffer += ret;
  
  //BODY
  aux1 = strstr(aux1, "<circle cx=");
  if(aux1 == NULL) {
    fprintf(stderr, "[%s:%d] Failed to parse first line\n", __FILE__, __LINE__); 
    return NULL;     
  }
  aux2 = aux1 + 1;
  while((aux2 = strstr(aux2, "<circle cx=")) != NULL) {
    if((tmp1 = strchr(aux1, '\n')) == NULL) {
      fprintf(stderr, "[%s:%d] Failed to parse line\n", __FILE__, __LINE__); 
      return NULL;    
    }
    if((tmp2 = strchr(aux2, '\n')) == NULL) {
      fprintf(stderr, "[%s:%d] Failed to parse line\n", __FILE__, __LINE__); 
      return NULL;    
    }
    
    if(!parse_line(aux1, &point1)) return NULL;
    if(!parse_line(aux2, &point2)) return NULL;
    get_path(&path_arr, point1, point2);
    ret=get_svgpath_line(&svgpath_line, path_arr) + 1; // +1 because of the '\0'
    
    write_line(&write_buffer, aux1, tmp1-aux1);
    write_line(&write_buffer, svgpath_line, ret);
        
    // Dont forgot the last one!
    if(strstr(tmp2, "<circle cx=") == NULL)
      write_line(&write_buffer, aux2, tmp2-aux2);
    
    aux1 = aux2;
    aux2 = tmp2;
        
    // Check buffer is big enough
    if(buffer_size*0.8 < write_buffer-built_buffer) {
      distance = write_buffer-built_buffer;
      buffer_size = buffer_size*2;
      if((built_buffer = realloc(built_buffer, sizeof(char) * buffer_size)) == NULL) {
        fprintf(stderr, "[%s:%d] ", __FILE__, __LINE__); perror("realloc");
        return NULL;   
      }
      write_buffer = built_buffer+distance;
    }
  }  
  
  // TAIL
  total_bytes = strlen(SVG_TAIL) + 1;
  if((ret = snprintf(write_buffer, total_bytes, SVG_TAIL)) != total_bytes-1) {
    fprintf(stderr, "[%s:%d] snprintf: Wrote %d instead of %d bytes\n", __FILE__, __LINE__, ret, total_bytes-1);
    return NULL;
  }
  write_buffer += ret;
  
  *size_to_write = write_buffer-built_buffer;   
  
  return built_buffer;    
}

int get_file_size(FILE* f) {
  int bufsize;
  
  if(fseek(f, 0L, SEEK_END) == -1) {
    fprintf(stderr, "[%s:%d] ", __FILE__, __LINE__); perror("fseek");
    return -1;    
  }  
  
  bufsize = ftell(f);
  
  if(fseek(f, 0L, SEEK_SET) == -1) {
    fprintf(stderr, "[%s:%d] ", __FILE__, __LINE__); perror("fseek");
    return -1;    
  }
  
  return bufsize;
}

int main(int argc, char* argv[]) {
  if (argc != 3) {
    printf("Usage: %s input_image.svg input_tour.cyc\n", argv[0]);
    return -1;
  }
  
  FILE * svg_file;
  FILE * cyc_file;
  FILE * out_file;
  char * input_svg_path = argv[1];
  char * input_cyc_path = argv[2];
  char * svg_buffer;
  char * cyc_buffer;
  char * out_buffer;
  int* cyc_array;
  int ret;
  int bufsize;
    
  // Open both files
  if((svg_file = fopen(input_svg_path, "r")) == NULL) {
    fprintf(stderr, "[%s:%d] ", __FILE__, __LINE__); perror("fopen");
    return -1;    
  }
  
  if((cyc_file = fopen(input_cyc_path, "r")) == NULL) {
    fprintf(stderr, "[%s:%d] ", __FILE__, __LINE__); perror("fopen");
    return -1;    
  }
  
  // Read svg file
  if((bufsize = get_file_size(svg_file)) == -1) return -1;
  
  if((svg_buffer = malloc(sizeof(char) * (bufsize+1))) == NULL) {
    fprintf(stderr, "[%s:%d] ", __FILE__, __LINE__); perror("malloc");
    return -1;    
  }
  
  if((ret = fread(svg_buffer, sizeof(char), bufsize, svg_file)) < bufsize) {
    if(ferror(svg_file) != 0)
      printf("fread: An error ocurred while reading\n");    
    else 
      printf("fread: Unexpected end of file (read %d expected %d)\n", ret, bufsize); 
    
    return -1;
  }
  
  // Read cyc file
  if((bufsize = get_file_size(cyc_file)) == -1) return -1;
  
  if((cyc_buffer = malloc(sizeof(char) * (bufsize+1))) == NULL) {
    fprintf(stderr, "[%s:%d] ", __FILE__, __LINE__); perror("malloc");
    return -1;    
  }
  
  if((ret = fread(cyc_buffer, sizeof(char), bufsize, cyc_file)) < bufsize) {
    if(ferror(cyc_file) != 0)
      printf("fread: An error ocurred while reading\n");    
    else 
      printf("fread: Unexpected end of file (read %d expected %d)\n", ret, bufsize); 
    
    return -1;
  }
  
  // Parse cyc as int array
  cyc_array = cyc_to_array(cyc_buffer);
  
  // Build output
  if((out_buffer = build_tsp2svg(cyc_array, svg_buffer, &bufsize)) == NULL) return -1;
    
  // Open the output file
  if((out_file = fopen(OUTPUT_FILENAME, "w")) == NULL) {
    fprintf(stderr, "[%s:%d] ", __FILE__, __LINE__); perror("fopen");
    return -1;    
  }  
  
  // Write output buffer to file
  if((ret = fwrite(out_buffer,  sizeof(char), bufsize, out_file)) != bufsize) {
    fprintf(stderr, "[%s:%d] fwrite: Wrote %d instead of %d bytes\n", __FILE__, __LINE__, ret, bufsize);
    return -1;    
  }
  
  // Clean everything, exit
  free(svg_buffer);
  free(cyc_array);
  
  if(fclose(svg_file) != 0) {
    fprintf(stderr, "[%s:%d] ", __FILE__, __LINE__); perror("fclose");
    return -1;    
  } 
  
  if(fclose(cyc_file) != 0) {
    fprintf(stderr, "[%s:%d] ", __FILE__, __LINE__); perror("fclose");
    return -1;    
  }
  
  if(fclose(out_file) != 0) {
    fprintf(stderr, "[%s:%d] ", __FILE__, __LINE__); perror("fclose");
    return -1;    
  } 
      
}
