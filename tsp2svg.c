#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <stdbool.h>
#include <libgen.h>
#include <math.h>
#include <float.h>

#define OUTPUT_FILENAME "solved.svg" 
#define SVG_HEADER "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n" \
                   "<!-- SVG generated by https://github.com/Dr-Noob/svg_extract -->\n" \
                   "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n" \
                   "<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"%dpx\" height=\"%dpx\">\n" \
                   "<g fill=\"black\" stroke=\"none\">\n"
#define SVG_TAIL "</g>\n" \
                 "</svg>\n"        
#define SVG_PATH "<path d=\"M %.3f,%.3f L %.3f,%.3f L %.3f,%.3f L %.3f,%.3f z\" fill=\"rgb(%d,%d,%d)\" />"
                     
#define SVG_CIRCLE "<circle cx=\"%.3f\" cy=\"%.3f\" r=\"%.3f\" />"
                 
#define PI_2 1.57079632679489661923                 
#define POINT_CX 0
#define POINT_CY 1
#define POINT_R  2                 
                 
int int_length(int num) { return floor(log10(abs(num))) + 1; }

bool get_svg_dims(int * width, int * height, char * svg_buffer) {
  char* tmp;
  char* svg_width_ptr;
  char* svg_height_ptr;
  char* svg_width;
  char* svg_height;
  
  // Width
  tmp = strstr(svg_buffer, "<svg width=");
  if(tmp == NULL) {
    fprintf(stderr, "[%s:%d] Could not find svg width\n", __FILE__, __LINE__);
    return false;
  }
  
  svg_width_ptr = tmp + 12;
  tmp = strstr(svg_width_ptr, "\" ");
  if(tmp == NULL) {
    fprintf(stderr, "[%s:%d] Failed to parse svg width\n", __FILE__, __LINE__);
    return false;    
  }
  
  if((svg_width = malloc(sizeof(char) * (tmp-svg_width_ptr+1))) == NULL) {
    fprintf(stderr, "[%s:%d] ", __FILE__, __LINE__); perror("malloc");
    return false;    
  }
  strncpy(svg_width, svg_width_ptr, tmp-svg_width_ptr);
  *width = atoi(svg_width);
  
  // Height
  tmp = strstr(svg_width_ptr, "height=");
  if(tmp == NULL) {
    fprintf(stderr, "[%s:%d] Could not find svg height\n", __FILE__, __LINE__);
    return false;
  }
  
  svg_height_ptr = tmp + 8;
  tmp = strstr(svg_height_ptr, "\" ");
  if(tmp == NULL) {
    fprintf(stderr, "[%s:%d] Failed to parse svg height\n", __FILE__, __LINE__);
    return false;    
  }
  
  if((svg_height = malloc(sizeof(char) * (tmp-svg_height_ptr+1))) == NULL) {
    fprintf(stderr, "[%s:%d] ", __FILE__, __LINE__); perror("malloc");
    return false;    
  }
  strncpy(svg_height, svg_height_ptr, tmp-svg_height_ptr);
  *height = atoi(svg_height);
  
  return true;  
}

int* cyc_to_array(int* cyc_length, char * cyc_buffer) {
  int n = 0;
  char * aux = cyc_buffer;    
  char * tmp;
  char coord[20];
  int c;
  
  while((aux = strchr(aux, '\n')) != NULL) {
    n++;   
    aux++;
  }
  
  int* cyc_array = malloc(sizeof(int) * n);
  aux = cyc_buffer-1;
  
  for(int i=0;i<n;i++) {
    aux++;
    tmp = strchr(aux, '\n');
    strncpy(coord, aux, tmp-aux);
    coord[tmp-aux] = 0;
    c = atoi(coord);
    
    cyc_array[i] = c;
    aux = strchr(aux, '\n');
  }
  
  *cyc_length = n;
  return cyc_array;
}

void get_path2(float** path_arr, float* point1, float* point2) {
  (*path_arr)[0] = point1[POINT_CX] - point1[POINT_R]/2;
  (*path_arr)[1] = point1[POINT_CY] - point1[POINT_R]/2;
  (*path_arr)[2] = point1[POINT_CX] + point1[POINT_R]/2;
  (*path_arr)[3] = point1[POINT_CY] + point1[POINT_R]/2;
  (*path_arr)[4] = point2[POINT_CX] - point2[POINT_R]/2;
  (*path_arr)[5] = point2[POINT_CY] - point2[POINT_R]/2;
  (*path_arr)[6] = point2[POINT_CX] + point2[POINT_R]/2;
  (*path_arr)[7] = point2[POINT_CY] + point2[POINT_R]/2;
}

// https://en.wikipedia.org/wiki/Tangent_lines_to_circles
void get_path(float** path_arr, float* point1, float* point2) {
  float x1 = point2[POINT_CX];
  float y1 = point2[POINT_CY];
  float r  = point2[POINT_R];
  float x2 = point1[POINT_CX];
  float y2 = point1[POINT_CY];
  float R  = point1[POINT_R];  
    
  float xdiff = (x2-x1)*(x2-x1);
  float ydiff = (y2-y1)*(y2-y1);
  float gamma = -atan((y2-y1)/(x2-x1));
  float beta = asin((R-r)/sqrtf(xdiff+ydiff));
  float alpha = gamma - beta;
  float rcos = r * cos(PI_2 - alpha);
  float rsin = r * sin(PI_2 - alpha);
  float Rcos = R * cos(PI_2 - alpha);
  float Rsin = R * sin(PI_2 - alpha);
  
  float x3 = x1 + rcos;
  float y3 = y1 + rsin;
  float x4 = x2 + Rcos;
  float y4 = y2 + Rsin;
  float x5 = x1 - rcos;
  float y5 = y1 - rsin;
  float x6 = x2 - Rcos;
  float y6 = y2 - Rsin;
  
  (*path_arr)[0] = x3;
  (*path_arr)[1] = y3;
  (*path_arr)[2] = x4;
  (*path_arr)[3] = y4;
  (*path_arr)[4] = x6;
  (*path_arr)[5] = y6;
  (*path_arr)[6] = x5;
  (*path_arr)[7] = y5;
}

bool parse_line(char* line, float** point) {
  char* tmp;
  char* svg_ptr;
  char svg_buffer[100];
  
  // CX
  tmp = strstr(line, "<circle cx=");
  if(tmp == NULL) {
    fprintf(stderr, "[%s:%d] Could not find circle cx\n", __FILE__, __LINE__);
    return false;
  }
  
  svg_ptr = tmp + 12;
  tmp = strstr(svg_ptr, "\" ");
  if(tmp == NULL) {
    fprintf(stderr, "[%s:%d] Failed to parse circle cx\n", __FILE__, __LINE__);
    return false;    
  }
  
  strncpy(svg_buffer, svg_ptr, tmp-svg_ptr);
  svg_buffer[tmp-svg_ptr] = '\0';
  (*point)[POINT_CX] = atof(svg_buffer);
  
  // CY
  tmp = strstr(line, "cy=");
  if(tmp == NULL) {
    fprintf(stderr, "[%s:%d] Could not find circle cy\n", __FILE__, __LINE__);
    return false;
  }
  
  svg_ptr = tmp + 4;
  tmp = strstr(svg_ptr, "\" ");
  if(tmp == NULL) {
    fprintf(stderr, "[%s:%d] Failed to parse circle cy\n", __FILE__, __LINE__);
    return false;    
  }
  
  strncpy(svg_buffer, svg_ptr, tmp-svg_ptr);
  svg_buffer[tmp-svg_ptr] = '\0';
  (*point)[POINT_CY] = atof(svg_buffer);
  
  // R
  tmp = strstr(line, "r=");
  if(tmp == NULL) {
    fprintf(stderr, "[%s:%d] Could not find circle r\n", __FILE__, __LINE__);
    return false;
  }
  
  svg_ptr = tmp + 3;
  tmp = strstr(svg_ptr, "\" ");
  if(tmp == NULL) {
    fprintf(stderr, "[%s:%d] Failed to parse circle r\n", __FILE__, __LINE__);
    return false;    
  }
  
  strncpy(svg_buffer, svg_ptr, tmp-svg_ptr);
  svg_buffer[tmp-svg_ptr] = '\0';
  (*point)[POINT_R] = atof(svg_buffer);
  
  return true;
}

int get_svgpath_line(char** svgpath_line, float* path_arr) {
  return sprintf(*svgpath_line, SVG_PATH, path_arr[0], path_arr[1], path_arr[2], path_arr[3], path_arr[4], path_arr[5], path_arr[6], path_arr[7], 0, 0, 0);
}

int get_circle_line(char** circle_line, float* circle_arr) {
  return sprintf(*circle_line, SVG_CIRCLE, circle_arr[POINT_CX], circle_arr[POINT_CY], circle_arr[POINT_R]);
}

void adjust_points(float** point_buffer, int number_of_points) {
  // Find max and min X and Y
  float max_x = FLT_MIN;
  float min_x = FLT_MAX;
  float max_y = FLT_MIN;
  float min_y = FLT_MAX;
  
  for(int i=0; i < number_of_points; i++) {
    if(point_buffer[i][POINT_CX] > max_x) max_x = point_buffer[i][POINT_CX];
    if(point_buffer[i][POINT_CY] > max_y) max_y = point_buffer[i][POINT_CY];
    if(point_buffer[i][POINT_CX] < min_x) min_x = point_buffer[i][POINT_CX];
    if(point_buffer[i][POINT_CY] < min_y) min_y = point_buffer[i][POINT_CY];
  }

  for(int i=0; i < number_of_points; i++) {
    point_buffer[i][POINT_CX] = point_buffer[i][POINT_CX] - min_x + 10;
    point_buffer[i][POINT_CY] = point_buffer[i][POINT_CY] - min_y + 10;
  }    
}

void write_line(char** write_buffer, char* line, int bytes_to_write) {
  strncpy(*write_buffer, line, bytes_to_write);
  
  //If found \r, original file ending was \r\n, replace \r with \n
  (*write_buffer)[bytes_to_write-1] = '\n';
  *write_buffer += bytes_to_write;
}

char* build_tsp2svg(int number_of_points, int* cyc_array, char* svg_buffer, int* size_to_write) {  
  int buffer_size = 1<<20;  
  int ret;
  int index = 0;
  int svg_width;
  int svg_height;
  int distance;
  float* path_arr = malloc(sizeof(float) * 8); // 4 points
  float** point_buffer = malloc((sizeof(float) * 3) * number_of_points);
  char* built_buffer = malloc(sizeof(char) * buffer_size);
  char* write_buffer = built_buffer;
  char* aux = svg_buffer;
  char* circle_line = malloc(sizeof(char) * 10000);
  char* svgpath_line = malloc(sizeof(char) * (strlen(SVG_PATH) - 4*8 + 10*8));
  // Substract %.3f format (4*8) and add values itself (we assume there will not be a number bigger than 100000.000)
  
  for(int i=0; i < number_of_points; i++)
    point_buffer[i] = malloc(sizeof(float) * 3); // x, y, and r
  
  if(!get_svg_dims(&svg_width, &svg_height, svg_buffer)) 
    return NULL;      

  // HEADER
  int total_bytes = strlen(SVG_HEADER)-4 + int_length(svg_width) + int_length(svg_height) + 1;
  if((ret = snprintf(write_buffer, total_bytes, SVG_HEADER, svg_width, svg_height)) != total_bytes-1) {
    fprintf(stderr, "[%s:%d] snprintf: Wrote %d instead of %d bytes\n", __FILE__, __LINE__, ret, total_bytes-1);
    return NULL;
  }  
  write_buffer += ret;
  
  //BODY
  // Parse
  while((aux = strstr(aux, "<circle cx=")) != NULL) {    
    if(!parse_line(aux, &point_buffer[index])) return NULL;
    
    index++;
    aux++;
  }
  
  // Re-compute
  //adjust_points(point_buffer, number_of_points);
  
  // Write
  for(int i=0; i<index; i++) {
    get_path(&path_arr, point_buffer[cyc_array[i]], point_buffer[cyc_array[i+1]]);
    
    ret=get_circle_line(&circle_line, point_buffer[cyc_array[i]]) + 1; // +1 because of the '\0'  
    write_line(&write_buffer, circle_line, ret);
    
    ret=get_svgpath_line(&svgpath_line, path_arr) + 1; // +1 because of the '\0'    
    write_line(&write_buffer, svgpath_line, ret);
                
    // Check buffer is big enough
    if(buffer_size*0.8 < write_buffer-built_buffer) {
      distance = write_buffer-built_buffer;
      buffer_size = buffer_size*2;
      if((built_buffer = realloc(built_buffer, sizeof(char) * buffer_size)) == NULL) {
        fprintf(stderr, "[%s:%d] ", __FILE__, __LINE__); perror("realloc");
        return NULL;   
      }
      write_buffer = built_buffer+distance;
    }
  } 
  
  // TAIL
  total_bytes = strlen(SVG_TAIL) + 1;
  if((ret = snprintf(write_buffer, total_bytes, SVG_TAIL)) != total_bytes-1) {
    fprintf(stderr, "[%s:%d] snprintf: Wrote %d instead of %d bytes\n", __FILE__, __LINE__, ret, total_bytes-1);
    return NULL;
  }
  write_buffer += ret;
  
  *size_to_write = write_buffer-built_buffer;   
  
  return built_buffer;    
}

int get_file_size(FILE* f) {
  int bufsize;
  
  if(fseek(f, 0L, SEEK_END) == -1) {
    fprintf(stderr, "[%s:%d] ", __FILE__, __LINE__); perror("fseek");
    return -1;    
  }  
  
  bufsize = ftell(f);
  
  if(fseek(f, 0L, SEEK_SET) == -1) {
    fprintf(stderr, "[%s:%d] ", __FILE__, __LINE__); perror("fseek");
    return -1;    
  }
  
  return bufsize;
}

int main(int argc, char* argv[]) {
  if (argc != 3) {
    printf("Usage: %s input_image.svg input_tour.cyc\n", argv[0]);
    return -1;
  }
  
  FILE * svg_file;
  FILE * cyc_file;
  FILE * out_file;
  char * input_svg_path = argv[1];
  char * input_cyc_path = argv[2];
  char * svg_buffer;
  char * cyc_buffer;
  char * out_buffer;
  int* cyc_array;
  int ret;
  int bufsize;
  int number_of_points;
  
  // Open both files
  if((svg_file = fopen(input_svg_path, "r")) == NULL) {
    fprintf(stderr, "[%s:%d] ", __FILE__, __LINE__); perror("fopen");
    return -1;    
  }
  
  if((cyc_file = fopen(input_cyc_path, "r")) == NULL) {
    fprintf(stderr, "[%s:%d] ", __FILE__, __LINE__); perror("fopen");
    return -1;    
  }
  
  // Read svg file
  if((bufsize = get_file_size(svg_file)) == -1) return -1;
  
  if((svg_buffer = malloc(sizeof(char) * (bufsize+1))) == NULL) {
    fprintf(stderr, "[%s:%d] ", __FILE__, __LINE__); perror("malloc");
    return -1;    
  }
  
  if((ret = fread(svg_buffer, sizeof(char), bufsize, svg_file)) < bufsize) {
    if(ferror(svg_file) != 0)
      printf("fread: An error ocurred while reading\n");    
    else 
      printf("fread: Unexpected end of file (read %d expected %d)\n", ret, bufsize); 
    
    return -1;
  }
  
  // Read cyc file
  if((bufsize = get_file_size(cyc_file)) == -1) return -1;
  
  if((cyc_buffer = malloc(sizeof(char) * (bufsize+1))) == NULL) {
    fprintf(stderr, "[%s:%d] ", __FILE__, __LINE__); perror("malloc");
    return -1;    
  }
  
  if((ret = fread(cyc_buffer, sizeof(char), bufsize, cyc_file)) < bufsize) {
    if(ferror(cyc_file) != 0)
      printf("fread: An error ocurred while reading\n");    
    else 
      printf("fread: Unexpected end of file (read %d expected %d)\n", ret, bufsize); 
    
    return -1;
  }
  
  // Parse cyc as int array
  cyc_array = cyc_to_array(&number_of_points, cyc_buffer);
  
  // Build output
  if((out_buffer = build_tsp2svg(number_of_points, cyc_array, svg_buffer, &bufsize)) == NULL) return -1;
    
  // Open the output file
  if((out_file = fopen(OUTPUT_FILENAME, "w")) == NULL) {
    fprintf(stderr, "[%s:%d] ", __FILE__, __LINE__); perror("fopen");
    return -1;    
  }  
  
  // Write output buffer to file
  if((ret = fwrite(out_buffer,  sizeof(char), bufsize, out_file)) != bufsize) {
    fprintf(stderr, "[%s:%d] fwrite: Wrote %d instead of %d bytes\n", __FILE__, __LINE__, ret, bufsize);
    return -1;    
  }
  
  // Clean everything, exit
  free(svg_buffer);
  free(cyc_array);
  
  if(fclose(svg_file) != 0) {
    fprintf(stderr, "[%s:%d] ", __FILE__, __LINE__); perror("fclose");
    return -1;    
  } 
  
  if(fclose(cyc_file) != 0) {
    fprintf(stderr, "[%s:%d] ", __FILE__, __LINE__); perror("fclose");
    return -1;    
  }
  
  if(fclose(out_file) != 0) {
    fprintf(stderr, "[%s:%d] ", __FILE__, __LINE__); perror("fclose");
    return -1;    
  } 
      
}
